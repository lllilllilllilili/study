## **제 11장 : CQRS**

제 11장 CQRS

## **단일 모델의 단점**

- 특정 서비스를 구현하기 위해서는 여러 애그리거트에서 데이터를 가져와야 한다.
- 페이지를 로딩이 시키는데 관련된 도메인 모델을 가져오기 때문에 쿼리를 여러번 날리게 되고 결과적으로 느려지게 된다.
- 구현의 복잡도가 존재하기 때문에 상태 변경을 위한 모델(Command)와 조회(Query)를 위한 모델을 분리하는 것이다.

## **CQRS**

- 시스템을 크게 상태를 변경하는 기능, 상태 정보를 조회하는 기능으로 나눌 수 있다.
- 단일 모델로 위 종류의 기능을 구현하면 모델이 복잡해진다.
    - 상태를 변경하는 범위, 상태를 조회하는 범위가 항상 그리고 정확하게 일치하지 않는다.
- 단일 모델을 사용할 때 발생하는 복잡도를 낮추기 위해 CQRS를 사용할 수 있다.


- CQRS(Command Query Responsibility Segregation)는 상태를 변경하는 명령(Command)과 조회(Query)를 위한 모델을 분리하는 패턴이다.
- CQRS는 도메인이 복잡할 수록 유리하다. 단일 모델에서 할 수 없는 처리 장점들이 존재한다.
- 예를 들어, 온라인 쇼핑몰에서 여러 채널에서 주문 및 판매 통계를 조회해야한다고 가정해보자.
    - JPA를 사용하고 단일 도메인 모델을 적용한다면 통계 값을 빠르게 조회하기 위해서 JPA와 관련된 여러 성능 기능을 단일 도메인 모델에 적용해야한다.
    - 이런 단일 도메인에서 CQRS를 적용하면 조회 모델과 상태를 변경하는 명령 모델을 별도로 만들기 때문에 조회 때문에 도메인이 복잡해지는 것을 예방할 수 있다. 

- CQRS 에서는 데이터베이스에서 데이터를 가져오는 매핑 프레임워크로 명령 모델은 객체 지향에 기반한 도메인 모델을 구현하기에 적당한 JPA를 사용하고 조회 모델에서는 DB에서 SQL로 데이터를 조회할 때 MyBatis를 사용해서 구현할 수 있다.

- 명령 모델과 조회 모델의 설계의 예
- 두 모델 모두 주문과 관련이 있지만 명령 모델은 상태를 변경하는 도메인 로직을 수행하는데 초점이, 조회 모델은 화면에 보여줄 데이터를 조회하는 데 초점이 맞춰 설계되었다.

- 또한 아예 명령을 위한 DB와 조회를 위한 DB를 구분해서 사용하는 것 또한 가능하다.

### CQRS 패턴을 적용하기 위한 별도의 기술이 존재하는 것은 아니다

### 명령 모델을 JPA로 구현하고 조회 모델은 직접 SQL을 사용해 구현할 수도 있다

## 웹과 CQRS

- 웹에서는 상태 변경 요청보다 상태 조회 요청이 더 많다.
- 조회 전용 모델을 캐싱하라
    - 카페인 캐시
    - 로컬 캐시 HashMap
- 조회 속도를 높이고 싶다면 반드시 명령 모델과 조회 모델을 분리하자

## CQRS 장단점
- 장점
  - 명령 모델을 구현할 때 도메인 자체에 집중할 수 있게 된다.
  - 캐시를 조회 단위로 적용할 수 있어 조회 성능을 향상시킬 수 있다.
- 단점
  - 구현해야 할 코드가 더 많다. 
  - 서비스의 트래픽이 낮다면 명령 모델과 조회 모델을 분리하지 않는것이 좋다.
- 더 많은 구현 기술이 필요하게 된다.
- 다른 저장소를 사용하거나, 다른 구현 기술을 사용해야 할 수도 있다.
- 데이터 동기화를 위해 메시징 시스템을 도입해야 할 수도 있다.

## 레이어 계층으로 자세히 살펴보면
1. 데이터 조회 및 데이터 전달 객체(DTO) 생성
- Controller: 사용자의 요청을 받고, 해당 요청을 처리하기 위해 서비스 레이어에 작업을 위임
- Service Layer(productService): 비즈니스 로직을 수행하고, 데이터베이스 CRUD 작업을 위해 레포지토리 레이어에 접근
- Repository Layer(productRepository): 실제 데이터베이스와 상호 작용하여 데이터를 조회하고, 조회한 데이터를 DTO(ProductDTO)로 변환하여 서비스 레이어로 전달
- Database(Oracle): 실제 데이터를 보유하고 있으며, 레포지토리 레이어의 쿼리에 응답

```java
xml
<!-- .xml 파일에서의 쿼리 예시 -->
<select id="findProductByNos" resultMap="ProductDTO">
  SELECT * FROM products WHERE product_no IN (xxx)
</select>
```
2. 데이터 변환 (Assembler 사용)
DTO to Domain Entity: ProductDTO를 도메인 엔터티(Product)로 변환하는 작업을 수행.

## CQRS 장점
- 복잡한 도메인은 상태 변경 로직이 복잡하지만 명령 모델과 조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을 구현하는 데 집중할 수 있다.
- 또 다른 장점은 조회 성능을 향상 시킬 수 있는 캐시를 조회 단위로 적용할 수 있다.
- 단점은 구현해야할 코드가 더 많다.
    - 트래픽이 많지 않은 서비스라면 명령 모델과 조회 모델을 분리하지는 말자.
- API설계시 아래와 같이 Impl 에 대한 코드를 추가해야할 수 있다. 

## Interface와 Implementation의 확장 및 정리
1. 다양한 이유로 인한 확장 필요성
   변화하는 비즈니스 로직: 시간이 지남에 따라 비즈니스 로직이 변화하거나 확장할 수 있다. 

2. Interface와 Impl 구조
```java
public interface ProductService {
   Product findProductById(Long id);
   // 기타 메서드 ...
   }
```
```java
public class ProductServiceImpl implements ProductService {
// ProductService의 메서드들을 구현
}
```
3. 확장의 예
   변경된 비즈니스 로직의 적용: 새로운 비즈니스 로직이나 기능이 추가될 때 기존 ServiceImpl 클래스에 영향을 최소화하면서 확장할 필요가 있다.

```java
public class EnhancedProductServiceImpl implements ProductService {
// 새로운 로직을 포함한 메서드 구현
}
```

- 두 번째 단점은 더 많은 구현 기술이 필요로할 수 있다.
    - 다른 저장소를 사용하거나 다른 구현 기술을 사용할 수 있다.
    - 데이터 동기화를 위해 메시징 시스템을 도입해야할 수도 있다.
    - 예시
    ```
      일반적으로 CQRS 아키텍처에서는 읽기 모델과, 쓰기 모델이 각기 다른 데이터 저장소를 사용합니다. 쓰기 모델에서 발생하는 데이터 변경(이벤트)을 읽기 모델로 동기화해야 하는데, 여기서 메시징 시스템이 중요한 역할을 한다.
      예를 들어, 온라인 상점에서 주문이 생성되면(쓰기), 이 정보는 비즈니스 로직을 통해 쓰기 데이터베이스에 저장됩니다. 이후에 발생하는 이 이벤트는 메시징 시스템을 통해 읽기 모델의 데이터베이스로 전달되어, 여기에도 동일한 주문 정보가 저장(동기화)되어 사용자 인터페이스나 외부 API 등을 통해 조회될 수 있습니다.
    ```
- 트래픽이 높은 서비스인데 단일 모델을 고려하게 되면 유지 보수 비용이 오히려 높아질 수 있다. 이런 경우 CQRS 도입을 고려해보면 도움이 될 수 있다. 