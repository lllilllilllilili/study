## Virtual Thread 란
2023년 9월 19일에 릴리즈된 Java 21 는 Java 8 이후 세번째 LTS 버전이다(11, 17, 21). 이 버전에서는 가상 스레드 라는 기능이 추가되었다.



가상 스레드 란 기존의 전통적인 Java 스레드에 더하여 추가된 경량 스레드이다.

OS 스레드를 그대로 사용하지 않고 JVM 자체적으로 내부 스케줄링을 통해서 사용할 수 있는 경량의 스레드를 제공한다.



## Virtual Thread 등장 배경
자바의 스레드는 OS의 스레드를 기반으로 한다.
OS 커널에서 사용할 수 있는 스레드는 갯수가 제한적이고 생성과 유지 비용이 비싸다.
처리량(throughput)의 한계
Spring Boot와 같은 애플리케이션의 기본적인 사용자 요청 처리 방식은 Thread Per Request 이다. 이는 하나의 request(요청)을 처리하기 위해서 하나의 스레드를 사용한다.
애플리케이션에서 처리량을 늘리려면 스레드를 늘려야 하지만 스레드를 무한정 늘릴 수 없다. (OS 스레드를 무한정 늘릴 수 없기 때문)
Blocking으로 인한 리소스 낭비
Thread per Request 모델에서는 요청을 처리하는 스레드에서 IO 작업 처리할 때 Blocking 이 일어난다.
이 때문에 Blocking 이 아니라 Non-blocknig 방식의 Reactive Programming이 발전하였다.
Reactive Programming의 단점
한정된 자원인 플랫폼 스레드가 Blocking 되면서 대기하는 데 소요된 스레드 자원을 Non-blocking 방식으로 변경하면서 다른 요청을 처리하는데 사용할 수 있게 되었다.
다만 이런 Reactive 코드는 작성하고 이해하는 비용을 높게 만들었다. (Mono, Flux)
자바 플랫폼의 디자인
자바 플랫폼은 전통적으로 스레드를 중심으로 구성되어 있었다.
스레드 호출 스택은 thread local을 사용하여 데이터와 컨텍스트를 연결하도록 설계되어 있다.


## 해결하고자 하는 문제
Java 개발자가 하드웨어의 성능을 잘 활용하는 높은 처리량(쓰루풋)의 서버를 작성하는 것
동시에 자바 플랫폼의 디자인과 조화를 이루는 코드를 생성할 수 있도록 하는 것


## Reactive Programming 과의 비교
Reactive programming 이 달성하고자 하는, 리소스를 효율적으로 사용하여 높은 처리량(throughput)을 감당하려는 목적은 동일하다.
가상 스레드를 사용하면 Non-blocking 에 대한 처리를 JVM 레벨에서 담당해준다.








## 구조
애플리케이션 코드가 플랫폼 스레드를 사용하면 실제로는 OS 스레드를 사용하는 것이다. 이 때 사용하는 스레드는 비용이 비싸기 때문에 스레드 풀 을 사용하여 접근하는 방식으로 사용해왔다.

이에 반해 가상 스레드는 OS 스레드를 감싼 구조가 아니기 때문에 애플리케이션 코드는 가상 스레드 풀 없이 사용하고 JVM 자체적으로 가상 스레드를 OS 스레드와 연결하는 스케줄링한다. 이 작업을 mount / unmount 라고 하고 기존에 플랫폼 스레드라고 하던 부분을 Carrier 스레드라고 한다. (가상 스레드를 실제 OS 스레드로 연결해준다는 의미)


위와 같은 구조는 가상 스레드가 수십~수백만까지 늘어날 수 있기 때문에 전통적인 플랫폼 스레드와 동일한 메모리 비용, 컨텍스트 비용이 발생하면 감당하기 어렵다. 따라서 플랫폼 스레드와 가상 스레드는 자원 사용량의 차이가 있다.




Thread.sleep 에 의해서 Blocking 되었지만 내부 가상 스레드 스케줄러에 의해서 다음 가상 스레드가 실행되기 때문에 전체 처리 시간은 2초에 가깝게 나온다. 이 것을 통해서 Blcoking 코드가 있더라도 가상 스레드를 사용하면 처리량이 늘어날 수 있다는 것을 예상할 수 있다.




Virtual Thread 캐시를 적용하면 안되는 이유

Thread 는 Thread Local을 가지고 있어서 Cache 해서 사용하는것으로 알고 있는데요
그래서 Thread Pool에서 내부 객체를 함께 사용하는데 Virtual Thread는 Thread Pool이 없어서 공유해서 사용하는 자원이 아니기 때문에 Thread Local의 데이터 사본에 Cache를 적용할 필요가 없는거 같습니다.

출처

https://findstar.pe.kr/2023/04/17/java-virtual-threads-1/
https://findstar.pe.kr/2023/07/02/java-virtual-threads-2/